1. Problem You’re Solving (Clear Definition)

	You are building a real-time collaborative plain-text editor where:

	Multiple users edit the same document concurrently

	Clients can disconnect, lag, retry, or crash

	The system must always converge to one correct document

	This is a distributed systems problem, not a frontend problem.

2. Core Rule (Non-Negotiable)
Server holds absolute truth

	That means:

		Server owns the authoritative document state

		Server owns the authoritative operation order

		Client state is disposable and eventually consistent

		Clients are allowed to:

			Drift

			Lie

			Go offline

			Replay requests

	The system must still work.

3. Client Model (What Clients Actually Do)

	Each client has:

		A local copy of the document at some version

		A queue of optimistic local edits (pending ops)

		No authority over final document state

	Clients:

		Apply edits locally for responsiveness

		Send operations to the server

		Accept server corrections without argument

4. Operation Model (This Is Critical)

	Clients do not send document diffs or files.
	They send operations.

	Each operation contains:

		operationId (globally unique, for deduplication)

		userId

		baseVersion (document version the client edited against)

		operationType (insert / delete / replace)
	
		position (character offset, not line/word)

		payload (text or length)

	Clients do not send:

		Success flags

		Updated versions

		Final positions (those are not trusted)

5. Server Processing Flow (Authoritative Pipeline)

	For every incoming operation:

		Authenticate user

		Check write permission

		Check operationId

		If duplicate → discard (idempotency)

		Check baseVersion

		If stale → transform the operation, not the document

		Apply operation to authoritative document

		Increment documentVersion

		Assign serverSequenceId

		Persist changes

		Broadcast operation to other clients

		Acknowledge sender

	Important:

		Server never mutates history

		Server never trusts client position

		Server never rewinds state

6. Version vs Sequence (You Must Not Mix These)
DocumentVersion

	Represents document state

	Increments after each applied operation

	Used to detect staleness

	ServerSequenceId

	Represents global ordering

	Strictly increasing

	Used for replay, buffering, and recovery

	They serve different purposes.

7. Persistence Model (Crash Survival Logic)
	Must be persisted

		If you lose these, your system is broken:

		Authoritative document content (or snapshots)

		DocumentVersion

		Operation log (ordered by serverSequenceId)

		OperationId registry (deduplication)

		Access control rules

	In-memory only

		Safe to lose:

			Connected clients

			Pending ops per client

			Presence info

			Cursor data

			Temporary buffers

	Rule:

		If the server crashes right now, what must survive?

		That decides persistence.

8. Why Snapshots Exist (And What They Really Are)

	A snapshot is:

		The entire document state

		At a specific documentVersion

		At a specific serverSequenceId

	Snapshots solve:

		Fast client joins

		Crash recovery

		Infinite log growth

	Snapshots are not optional for real systems.

9. New Client Join Protocol (Correct Flow)
Server → Client

	Snapshot content

		snapshotVersion

		snapshotSequenceId

	Server immediately:

		Starts buffering new operations for that client

	Client

		Applies snapshot

		Sets local version = snapshotVersion

		Does NOT apply live ops yet

		Client → Server

		Lightweight acknowledgment: snapshotSequenceId applied

	Server → Client

		Sends all ops where
		serverSequenceId > snapshotSequenceId

		Switches client to live broadcast stream

	Guarantee:

		Client never applies an op with sequenceId ≤ snapshotSequenceId

10. What Happens During Snapshot Apply

	Operations may continue on the server

	Server buffers them per client

	Client catches up after snapshot is applied

	Ordering is preserved by serverSequenceId

	No document comparison is needed.

11. Failure Assumptions (Built Into Design)

	Your system already assumes:

		Network failures

		Duplicate requests

		Out-of-order delivery

		Client crashes

		Temporary divergence

		And still converges.

	That means your design is correctly paranoid.

SUMMARY:

The server is the single source of truth for document state and operation order.
Clients maintain local optimistic state but must always converge to the server state.

Clients send edit operations containing an operationId, userId, baseVersion, operation type, position, and payload.
The server authenticates and authorizes the request, checks for duplicate operations, rebases the operation if its baseVersion is stale, applies it to the authoritative document, assigns ordering metadata, persists it, and broadcasts it to all clients.

Clients acknowledge server responses, clear pending operations, and replay server-authoritative updates to maintain consistency.


							ARCHITECHURE DESIGN

1. System Goal (Re-anchoring)

	A real-time collaborative plain-text editor where:

	Server is authoritative

	Clients converge

	Edits are ordered, durable, and replayable

	System survives crashes and reconnects

	Everything in the architecture serves this goal.




							[ Client (Web/App) ]
       								|
        								|  WebSocket (ops, sync, acks)
        							        v
							[ Realtime Gateway ]
        								|
        								v
							[ Collaboration Core ]
        								|
        								|-------------------|
        								|                   |
       								 v                   v
							[ Persistence Layer ]   [ Snapshot Manager ]

3. Component Breakdown (Very Important)
	3.1 Client

		Responsibilities:

		Render document

		Apply optimistic edits

		Track pending operations

		Reconcile server updates

		Non-responsibilities:

		Conflict resolution

		Ordering

		Authority

		Clients are dumb but fast.

	3.2 Realtime Gateway

		Think of this as a traffic controller, not a brain.

		Responsibilities:

		Maintain WebSocket connections

		Authenticate clients

		Route messages to Collaboration Core

		Broadcast server-approved ops

	Non-responsibilities:

		Document mutation

		Versioning

		Rebase logic

	Why separate it:

		Lets you scale connections independently

		Keeps core logic clean

	3.3 Collaboration Core (The Brain)

		This is the most important component.

		Responsibilities:

			Validate operations

			Deduplicate operationIds

			Transform operations (rebasing)

			Apply operations to document state

			Assign serverSequenceId

			Increment documentVersion

			Decide broadcast order

		Rules:

			Single authority per document

			Deterministic behavior

			No side effects outside persistence

			This component enforces truth.

	3.4 Persistence Layer

			Responsibilities:

			Store authoritative document content

			Store operation logs

			Store snapshots

			Store permissions

			Store deduplication state

		Characteristics:

			Durable

			Ordered writes

			Crash-safe

			No business logic here.

	3.5 Snapshot Manager

		Responsibilities:

			Decide when to snapshot

			Create snapshots from document state

			Prune old operation logs

			Assist new client sync

		This can be:

			A background worker

			Or part of Collaboration Core initially

			But conceptually, it is separate.

4. Document Ownership Model (Crucial Decision)
One document = one authority

	For each document:

		Exactly one active Collaboration Core instance owns it

		All ops for that document go through it

		Guarantees strict ordering

	This avoids:

		Cross-node conflicts

		Distributed locks

		Consensus nightmares

		Scaling happens by:

		Sharding documents, not operations

5. Request / Response Flow (Edit Path)
	Client edits

		→ Sends operation via WebSocket

	Realtime Gateway

		→ Auth check
		→ Forward to Collaboration Core

	Collaboration Core

		Deduplicate operationId

		Rebase if baseVersion is stale

		Apply operation

		Persist

		Broadcast op

	Clients

		→ Apply op
		→ Clear pending optimistic state

	This is your hot path. Keep it fast.

6. Join / Reconnect Flow (Sync Path)
	Client connects

		→ Requests document

	Server

		→ Fetch snapshot
		→ Send snapshot + metadata
		→ Buffer new ops

	Client

		→ Apply snapshot
		→ Ack snapshot

	Server

		→ Send buffered ops
		→ Switch client to live stream

	No races. No guessing.

7. Failure Boundaries (Explicit)
	If client crashes

		Server unaffected

	Client resyncs via snapshot

		If server crashes

	Persisted state restores

		Clients reconnect and resync

	If gateway crashes

		Connections drop

		No data corruption
	
	Every failure is contained.

8. What This Architecture Is NOT

	Not peer-to-peer

	Not CRDT-based (yet)

	Not git

	Not multi-writer authority

	It is:

		Centralized authority

		Deterministic

		Debuggable


	
										SCALABLITY

								How do we handle 10000 or more documents simultanously?

[ Client ]
   |
   |  WebSocket (docId)
   v
[ Realtime Gateway ]
   |
   |  hash(docId)
   v
[ Document Router ]
   |
   v
[ Collaboration Core Instance ]



								What MUST be loaded into RAM when a document is owned
These are non-negotiable.

Load into RAM immediately

Authoritative document content

The actual text (string / rope / buffer)

Without this, you cannot apply edits

Current documentVersion

Single integer

Used to validate and transform operations

Current serverSequenceId

Last applied global sequence number

Used to order new operations

Recent operation window (bounded)

Small in-memory buffer of recent ops

Used for rebasing stale client operations

Connected clients list (for this doc)

Socket references, not identities

Purely ephemeral

If these are not in RAM, your “real-time” editor is fake.



3. What must stay persisted on disk

This is your durability layer.

Persisted (disk / DB / storage)

Snapshots

Document content

snapshotVersion

snapshotSequenceId

Operation log

Ordered by serverSequenceId

Append-only

Document metadata

documentId

permissions

owner info

Deduplication state

operationIds already applied

Can be pruned, but must survive crashes



What fields exist in the in-memory representation of a document owned by a collaboration core?

DocumentState {
  documentId            // identifier
  content               // authoritative text buffer
  version               // current document version
  lastSequenceId        // last applied global sequence
  recentOperations      // bounded buffer for rebasing
  connectedClients      // ephemeral references
}


FLOW FOR THE COLLABORATIVE CORE

Here is the correct step-by-step flow inside the Collaboration Core:

Verify document write permission

Check deduplication store for operationId

If duplicate → discard

Register operationId as seen

Compare baseVersion with current documentVersion

If too stale → reject or resync

Transform operation using in-memory recentOperations

Apply transformed operation to document content

Increment documentVersion

Increment serverSequenceId

Persist operation (log)

Append operation to recentOperations buffer

Broadcast operation to connected clients

Acknowledge sender with metadata

If snapshot threshold reached → signal snapshot manager		



PROJECT ROADMAP — REAL-TIME COLLABORATIVE EDITOR

================================================
PHASE 1 — PLATFORM & ACCESS CONTROL (FOUNDATION)
================================================

Goal:
Establish identity, ownership, and permissions without leaking
collaboration logic into the system.

Scope:
- User authentication (signup / login)
- JWT-based authorization
- User discovery (search users)
- Document creation
- Invite collaborators to documents
- Read / write permission management
- REST-based APIs only

Explicitly excluded:
- Document content storage
- Real-time editing
- Versioning
- Operations
- Snapshots
- WebSockets
- Concurrency handling

Core rule:
Auth decides WHO can access a document.
It does NOT decide HOW the document changes.

------------------------------------------------

================================================
PHASE 2 — COLLABORATION ENGINE (CORE SYSTEM)
================================================

Goal:
Build a correct, server-authoritative real-time editing engine.

Scope:
- Single plain-text document per session
- Server holds authoritative document state
- Operation-based protocol (insert / delete / replace)
- Operation IDs and baseVersion tracking
- Deduplication via sliding recent-op window
- Rebasing stale operations
- Server-assigned document versions
- Snapshot-based resynchronization
- In-memory document state
- Append-only operation logs (persistence)

Explicitly excluded:
- Rich text
- Multiple documents per session
- Folder structures
- UI polish
- Cursor synchronization
- Presence indicators

Core rule:
Clients send INTENT (operations), not state (documents).
Server decides reality.

------------------------------------------------

================================================
PHASE 3 — HARDENING, SCALE & EXPERIENCE
================================================

Goal:
Make the system resilient, scalable, and usable at scale.

Scope:
- WebSocket transport
- Reconnect & resync handling
- Out-of-order operation handling
- Network failure simulation
- Snapshot compaction
- Memory pressure handling
- Document sharding (10k+ documents)
- Multi-instance routing
- Latency optimization
- Editor UX improvements
- Cursor presence (optional)
- Stress testing & edge cases

Explicitly excluded:
- Core collaboration logic redesign
- Auth changes
- Protocol rewrites

Core rule:
Scale via routing and ownership, not shared mutable state.

================================================


backend/
├── config/
│   ├── dbConnect.js
│   ├── passportConnect.js
│   └── redisConfig.js

├── prisma/
│   ├── schema.prisma
│   └── migrations/

├── generated/
│   └── prisma/

├── scripts/
│   ├── generateMigration.js
│   ├── generateModel.js
│   └── generateModule.js

├── globals/
│   ├── constants.js
│   └── response.json

├── helpers/
│   ├── apiResponse.js
│   └── generateToken.js

├── middleware/
│   └── verifyToken.js

├── modules/                ← Phase 1 lives here
│   ├── auth/
│   ├── user/
│   ├── document/
│   │   ├── routes/
│   │   └── services/
│   └── collaborator/
│       ├── routes/
│       └── services/

├── realtime/               ← Phase 2 starts here
│   ├── gateway/
│   │   ├── httpGateway.js
│   │   └── wsGateway.js
│   │
│   ├── engine/
│   │   ├── DocumentState.js
│   │   ├── Operation.js
│   │   ├── CollabEngine.js
│   │   ├── Rebase.js
│   │   └── Snapshot.js
│   │
│   ├── memory/
│   │   ├── documentStore.js
│   │   └── opWindow.js
│   │
│   └── persistence/
│       ├── snapshotRepo.js
│       └── opLogRepo.js

├── routes/
│   └── index.js

├── server.js
└── README.md

To Do section: 

Step 4 — Add op compression / batching

Merge multiple inserts/deletes from same client into one canonical op before rebasing.

This reduces window churn and DB load.

Step 5 — Add document lifecycle

Implement:

auto snapshot eviction

op window trimming per document

idle document unload

Right now memory will grow forever.

Step 6 — Permission gates

Only after realtime is stable:

integrate auth

add ACL per document

enforce write scopes

Do not touch auth until steps 1–5 are done.

Step 7 — Frontend binding

Only now do you wire React.

Not before.


COLLABORATIVE DEV PLATFORM MODEL

You are no longer building “a realtime editor.”

You are building a remote multi-user development operating system.

Everything below is deterministic and production-grade.

1. Core Entities
Project

Logical product unit.

Contains:

repo URL or blank workspace

access control rules

billing / quotas

linked workspace

Workspace (Runtime)

A running isolated compute environment.

Properties:

containerId

mounted project volume

code-server process

exposed web socket endpoint

lifecycle state (starting, running, stopped)

One workspace = one active project runtime.

User Session

JWT authenticated

Bound to a workspace

Proxied into VS Code server

No direct container access

2. Control Plane vs Data Plane
Plane	Your System	VS Code
Control	Your backend	—
Data (editing)	VS Code server	—
Versioning	Your engine	—
Recovery	Your engine	—
Audit	Your engine	—

VS Code only edits files.

Your system controls reality.

3. Workspace Lifecycle
Start
POST /workspace/start


Validate permission

Create container

Mount project volume

Start code-server

Register workspace record

Return secure gateway URL

Stop
POST /workspace/stop


Stop container

Persist snapshot

Unmount volume

Release resources

4. Editing Flow
VS Code edits files
        ↓
Filesystem watcher
        ↓
Your file→op bridge
        ↓
CollabEngine
        ↓
Append op log
        ↓
Snapshot / versioning


This is where your existing engine is reused.

5. Join Flow
User opens workspace URL
        ↓
Gateway validates JWT
        ↓
Proxy into code-server
        ↓
VS Code UI loads
        ↓
Live Share handles cursors & presence


No custom cursor logic anymore.

6. Crash Recovery

Crash → Restart → Reload snapshot → Replay op log → Workspace restored.

VS Code reconnects and continues.

7. Why your engine still matters

VS Code has no concept of:

• deterministic version history
• audit trails
• compliance snapshots
• replayable logs
• regulatory immutability

Your engine provides all of that.

This makes your platform enterprise-grade, not just “an editor.”


PHASE 0 — Freeze

Do not add any frontend.
Do not add VS Code yet.
Do not touch realtime logic.

We first convert your persistence layer to workspace-correct reality.

PHASE 1 — Introduce workspace layer (additive, non-breaking)

Add new tables without deleting old ones.

1. Add enums
enum WorkspaceStatus {
  ACTIVE
  STOPPED
  DELETED
}

enum WorkspaceRole {
  OWNER
  EDITOR
  VIEWER
}

2. Add workspace core
model Workspace {
  id        String   @id @default(cuid())
  name      String
  ownerId   String
  status    WorkspaceStatus @default(ACTIVE)
  mountPath String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner   User @relation(fields: [ownerId], references: [id])
  members WorkspaceMember[]
  files   File[]
}

3. Members
model WorkspaceMember {
  id          String   @id @default(cuid())
  workspaceId String
  userId      String
  role        WorkspaceRole

  @@unique([workspaceId, userId])
}

4. Files
model File {
  id          String   @id @default(cuid())
  workspaceId String
  path        String
  version     Int @default(0)
  currentHash String

  workspace Workspace @relation(fields: [workspaceId], references: [id])
}

5. File logs
model FileSnapshot {
  id      String @id @default(cuid())
  fileId  String
  version Int
  hash    String
  content String
  createdAt DateTime @default(now())

  @@index([fileId, version])
}

model FileOperationLog {
  id      String @id @default(cuid())
  fileId  String
  version Int
  op      Json
  createdAt DateTime @default(now())

  @@index([fileId, version])
}


Run migration. Do not remove Document yet.

PHASE 2 — Redirect collaboration core

You will not touch rebasing logic.

You only change storage target:

Old	New
documentId	fileId
DocumentState	FileState
DocumentSnapshot	FileSnapshot
OperationLog	FileOperationLog

Your engine remains identical in logic.

PHASE 3 — Workspace FS mount

Each workspace maps to:

/mnt/workspaces/{workspaceId}/


Files map to:

/mnt/workspaces/{workspaceId}/{path}


Snapshots hydrate files.
Operations stream patch files.
The DB is your history; the FS is your working tree.

PHASE 4 — VS Code attachment

code-server points to mountPath.

Your platform now controls:

• Who can open
• Which workspace
• Which files
• Which users
• Which ops are streamed

VS Code becomes a terminal, not the authority.

PHASE 5 — Delete Document model

Only after real users are editing workspaces successfully.


**Why VS Code / code-server Cannot Be Used for a Real Collaborative IDE**

VS Code (and code-server) cannot be used as the foundation of a real multi-user collaborative IDE.
It was never designed for it and is structurally hostile to it.

This is not an implementation gap.
This is a core architecture limitation.

1. VS Code is single-writer by design

VS Code assumes:

• One human
• One UI
• One filesystem
• One cursor authority
• One writer

Every core subsystem is built on this assumption.

There is no concept of shared document authority in VS Code’s architecture.

2. Disk is the source of truth

VS Code uses:

Editor Buffer → Disk → File Watcher → Reload


Meaning:

• Any external write is treated as “foreign corruption”
• VS Code tries to rebase local buffers on disk diffs
• This breaks cursor positions, undo stacks, and change streams

The moment two users write concurrently, the editor fights itself.

3. Cursor rebasing is not programmable

VS Code rebases cursors internally with no interception layer.

You cannot inject your own CRDT/OT cursor model.
You cannot override buffer authority.
You cannot make your engine authoritative.

Your system will always be subordinate — and will always lose.

4. File watchers destroy multi-user correctness

VS Code file watchers are designed for:

• Build tools
• Git
• Linting
• Local compilers

Not multi-writer collaboration.

They actively corrupt concurrent edits.

5. code-server inherits all of this

code-server is only VS Code in a browser.
It does not change the editor kernel.

So every concurrency flaw remains.

6. You cannot “patch” this away

You would have to:

• Replace the document model
• Replace the cursor model
• Replace undo/redo
• Replace the file watcher
• Replace FS authority
• Replace editor kernel

At that point, you are rewriting VS Code.

7. This is why cloud IDEs do NOT use VS Code kernel

Gitpod
Eclipse Che
Red Hat DevSpaces
Coder Workspaces
JetBrains Fleet (cloud mode)

They all use Theia-class architectures — not VS Code kernel.

Bottom line

VS Code is a local single-writer editor.
Trying to turn it into a collaborative IDE will always result in:

• Merge corruption
• Cursor desync
• Undo corruption
• Lost writes
• Phantom diffs
• Random reload prompts

These are not bugs.
They are architectural.


What You Use
Layer	Choice
UI IDE	Eclipse Theia
Terminal / FS	Docker container
Language services	LSP servers
Your Collab Engine	Authority layer
Disk	Append-only snapshot store
Phase 1 — Replace VS Code with Theia

Do not use VS Code or code-server.

Use:

theia/theia-full


This is the same stack used by Gitpod, Che, RedHat DevSpaces.

Phase 2 — Make Your Engine Authoritative

Your system becomes:

Browser Theia
    ↓
Your Collaboration Gateway
    ↓
CRDT / OT Core
    ↓
Disk Snapshots


Theia becomes read/write relay only.

Phase 3 — Disable Local FS Authority

In Theia:

• Disable file watcher reloads
• Disable file dirty conflict popups
• Disable buffer rebasing
• Disable native FS writes

Your engine handles all writes.

Theia only requests:

OPEN
CHANGE
SAVE


You decide when disk is written.

Phase 4 — Replace Theia FileSystem with Remote Provider

Mount a virtual FS:

theia.filesystem.remote


Point it to:

/api/workspace/:id/fs/*


Which routes to your engine.

Theia now sees your engine as “the disk”.

Phase 5 — Inject Your Collab Protocol

Implement:

API	Purpose
OPEN	Fetch doc state
PATCH	Apply CRDT delta
CURSOR	Cursor updates
SAVE	Snapshot flush

Theia editor simply renders your CRDT document.

Phase 6 — Terminals, Git, Builds

Run everything inside the workspace container:

Docker Workspace Container
 ├── LSP Servers
 ├── Git
 ├── Build tools
 └── Terminal


Expose through Theia.

Phase 7 — Snapshots & Recovery

Your engine periodically snapshots:

• Files
• Cursor state
• Undo logs
• Operation logs

Crash = replay logs.

Phase 8 — Security & Multi-Tenancy

Workspace container per workspace
Reverse proxy routes to correct Theia instance.

Result

You now have:

• True multi-cursor editing
• No merge conflicts
• No rebase corruption
• Deterministic state
• Real cloud IDE

What You Do NOT Do

• Do not mount host disk directly
• Do not allow Theia to write files
• Do not let file watchers control authority

This architecture is what Gitpod and Che use.